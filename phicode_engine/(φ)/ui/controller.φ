# (φ) phicode_engine/(φ)/ui/controller.φ

← config ⇒ (GRID_WIDTH, GRID_HEIGHT, SPEED, SPEED_INCREMENT, MIN_SPEED, BONUS_FOOD_CHANCE, BONUS_FOOD_POINTS, STATE_SIZE, ACTION_SIZE)
← core.snake ⇒ Snake
← core.food ⇒ spawn_food, should_spawn_bonus
← core.score ⇒ ScoreManager
← ui.renderer ⇒ Renderer
← ui.input_handler ⇒ InputHandler
← ui.bonus_manager ⇒ BonusFoodManager

← ai.agent_plugin ⇒ AgentPlugin
← ai.connector ⇒ Connector

⇒ time

ℂ GameController:
    ƒ __init__(self, root, canvas):
        self.root = root
        self.canvas = canvas
        self.renderer = Renderer(canvas)
        self.score = ScoreManager()

        self.games_played = 0
        self.time_playing = 0.0
        self._last_update_time = time.time()

        self._init_game_entities()

        self.bonus_manager = BonusFoodManager(self.root, self.snake.body, self.food, spawn_food)

        self.input_handler = InputHandler(
            root,
            self.snake,
        )

        self.agent = AgentPlugin(state_size=STATE_SIZE, action_size=ACTION_SIZE)
        self.agent.load()
        self.connector = Connector(self, self.agent)

        self.current_speed = SPEED
        self.running = ✓

        self._game_loop()

    ƒ _init_game_entities(self):
        self.snake = Snake((5, 5))
        self.food = spawn_food(self.snake.body, GRID_WIDTH, GRID_HEIGHT)
        self.score.reset()

    ƒ _increase_speed(self):
        new_speed = self.current_speed - SPEED_INCREMENT
        ¿ new_speed < MIN_SPEED:
            new_speed = MIN_SPEED
        self.current_speed = new_speed

    ƒ _end_game(self):
        self.agent.save()
        self.running = ⊥
        self.bonus_manager.remove_bonus_food()
        self.canvas.delete("all")
        self._start_new_game()

    ƒ _start_new_game(self):
        self.games_played += 1
        self._init_game_entities()
        self.bonus_manager = BonusFoodManager(self.root, self.snake.body, self.food, spawn_food)
        self.running = ✓
        self.current_speed = SPEED
        self._last_update_time = time.time()
        self._game_loop()

    ƒ _game_loop(self):
        ¿ ¬ self.running:
            ⟲

        current_time = time.time()
        delta = current_time - self._last_update_time
        self._last_update_time = current_time
        self.update_time(delta)

        self.connector.update()

        self.snake.move()
        head = self.snake.get_head()
        prev_head = self.snake.get_previous_head()
        prev_food_dist = abs(prev_head[0] - self.food[0]) + abs(prev_head[1] - self.food[1])
        curr_food_dist = abs(head[0] - self.food[0]) + abs(head[1] - self.food[1])
        delta_dist = prev_food_dist - curr_food_dist

        game_over = ⊥
        ¿ ¬ (0 <= head[0] < GRID_WIDTH) ∨ ¬ (0 <= head[1] < GRID_HEIGHT) ∨ self.snake.hits_self():
            game_over = ✓

        ¿ head == self.food:
            self.snake.grow()
            self.score.increment()
            self._increase_speed()
            self.food = spawn_food(self.snake.body, GRID_WIDTH, GRID_HEIGHT)

            ¿ ¬ self.bonus_manager.bonus_food ∧ should_spawn_bonus(BONUS_FOOD_CHANCE):
                self.bonus_manager.spawn_bonus_food()

        ¿ self.bonus_manager.bonus_food ∧ head == self.bonus_manager.bonus_food:
            self.snake.grow()
            self.score.increment(BONUS_FOOD_POINTS)
            self.bonus_manager.remove_bonus_food()

        game_info = {
            "ate_food": head == self.food,
            "ate_bonus_food": self.bonus_manager.bonus_food ∧ head == self.bonus_manager.bonus_food,
            "collision": game_over,
            "distance_to_food_delta": delta_dist,
            "violation": "collision" ¿ game_over ⋄ Ø,
        }

        self.renderer.draw_from_controller(self)

        self.agent.remember_and_train(self, game_info, game_over)

        ¿ game_over:
            self._end_game()
            ⟲

        self.root.after(self.current_speed, self._game_loop)

    ƒ update_time(self, delta_seconds):
        self.time_playing += delta_seconds