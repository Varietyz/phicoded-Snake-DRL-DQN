

=== File: phicode_engine\mapping.py ===

# mapping.py

PYTHON_TO_PHICODE = {
    "False": "⊥",
    "None": "Ø",
    "True": "✓",
    "and": "∧",
    "as": "↦",
    "assert": "‼",
    "async": "⟳",
    "await": "⌛",
    "break": "⇲",
    "class": "ℂ",
    "continue": "⇉",
    "def": "ƒ",
    "del": "∂",
    "elif": "⤷",
    "else": "⋄",
    "except": "⛒",
    "finally": "⇗",
    "for": "∀",
    "from": "←",
    "global": "⟁",
    "if": "¿",
    "import": "⇒",
    "in": "∈",
    "is": "≡",
    "lambda": "λ",
    "nonlocal": "∇",
    "not": "¬",
    "or": "∨",
    "pass": "⋯",
    "raise": "↑",
    "return": "⟲",
    "try": "∴",
    "while": "↻",
    "with": "∥",
    "yield": "⟰",
    "print": "π",
}

# Invert dictionary for decoding PHICODE -> Python
PHICODE_TO_PYTHON = {v: k for k, v in PYTHON_TO_PHICODE.items()}


=== File: phicode_engine\phicode_importer.py ===

# phicode_importer.py

import importlib.abc
import importlib.util
import sys
import os

from mapping import PHICODE_TO_PYTHON

class PhicodeLoader(importlib.abc.Loader):
    def __init__(self, path):
        self.path = path

    def create_module(self, spec):
        # Use default module creation semantics
        return None

    def exec_module(self, module):
        with open(self.path, 'r', encoding='utf-8') as f:
            phicode_source = f.read()

        # Decode PHICODE → Python keywords
        python_source = phicode_source
        for symbol, pyword in PHICODE_TO_PYTHON.items():
            python_source = python_source.replace(symbol, pyword)

        # Execute the Python code in the module's namespace
        exec(python_source, module.__dict__)


class PhicodeFinder(importlib.abc.MetaPathFinder):
    def __init__(self, base_path):
        self.base_path = base_path

    def find_spec(self, fullname, path, target=None):
        # Map module name to a .φ file under base_path
        parts = fullname.split('.')
        filename = os.path.join(self.base_path, *parts) + '.φ'

        if os.path.isfile(filename):
            loader = PhicodeLoader(filename)
            return importlib.util.spec_from_file_location(fullname, filename, loader=loader)
        else:
            # Check if it's a package (directory with __init__.φ)
            package_dir = os.path.join(self.base_path, *parts)
            init_file = os.path.join(package_dir, '__init__.φ')
            if os.path.isfile(init_file):
                loader = PhicodeLoader(init_file)
                return importlib.util.spec_from_file_location(fullname, init_file, loader=loader, submodule_search_locations=[package_dir])
        return None


def install_phicode_importer(base_path: str):
    """
    Add PHICODE importer to sys.meta_path with the given base source folder
    """
    finder = PhicodeFinder(base_path)
    sys.meta_path.insert(0, finder)


=== File: phicode_engine\runtime.py ===

# runtime.py

import sys
import os
import traceback
from phicode_importer import install_phicode_importer

def main():
    # Default module to run
    module_name = "main"

    # φ is the default PHICODE source folder; adjust if needed
    phicode_src_folder = 'phicode_engine/(φ)'
    if not os.path.isdir(phicode_src_folder):
        print(f"PHICODE source folder not found: {phicode_src_folder}", file=sys.stderr)
        sys.exit(2)

    # Install the PHICODE import system
    install_phicode_importer(phicode_src_folder)

    try:
        # Import 'main' module automatically
        __import__(module_name)
    except Exception as e:
        print(f"Error running module '{module_name}': {e}", file=sys.stderr)
        traceback.print_exc()
        sys.exit(3)

if __name__ == "__main__":
    main()


=== File: phicode_engine\__init__.py ===

# __init__.py
# PHICODE engine package

 
=== File: phicode_engine\(φ)\gui.φ ===

⇒ tkinter ↦ tk
⇒ logic

ƒ CalculatorGUI(logic):
    root = tk.Tk()
    root.title("PHICODE Modular Calculator")

    entry = tk.Entry(root, width=16, font=("Arial", 24), justify="right")
    entry.grid(row=0, column=0, columnspan=4)

    ƒ update_display():
        entry.delete(0, tk.END)
        entry.insert(0, logic.get_expr())

    buttons = [
        ("7", 1, 0), ("8", 1, 1), ("9", 1, 2), ("/", 1, 3),
        ("4", 2, 0), ("5", 2, 1), ("6", 2, 2), ("*", 2, 3),
        ("1", 3, 0), ("2", 3, 1), ("3", 3, 2), ("-", 3, 3),
        ("C", 4, 0), ("0", 4, 1), ("=", 4, 2), ("+", 4, 3),
    ]

    ∀ (text, r, c) in buttons:
        btn = tk.Button(root, text=text, width=4, height=2, font=("Arial", 18))
        btn.grid(row=r, column=c)

        ¿ text == "C":
            btn.configure(command=lambda: [logic.clear(), update_display()])
        ⤷ text == "=":
            btn.configure(command=lambda: [entry.delete(0, tk.END), entry.insert(0, logic.evaluate())])
        ⋄:
            btn.configure(command=lambda t=text: [logic.press(t), update_display()])


    root.mainloop()


=== File: phicode_engine\(φ)\logic.φ ===

ƒ CalculatorLogic():
    ƒ __init__(self):
        self.expr = ""  # ✓ Proper instance variable

    ƒ press(self, key):
        self.expr += key  # ✓ Fixed scope

    ƒ clear(self):
        self.expr = ""

    ƒ get_expr(self):
        ⟲ self.expr

    ƒ evaluate(self):
        ∴:
            result = str(eval(self.expr))
            self.expr = result
            ⟲ result
        ⛒ Exception:
            self.expr = ""
            ⟲ "Error"

    ⟲ type("CalculatorLogic", (), {
        "__init__": __init__,
        "press": press,
        "clear": clear,
        "get_expr": get_expr,
        "evaluate": evaluate
    })()  # ✓ Proper class construction

=== File: phicode_engine\(φ)\main.φ ===

⇒ gui
⇒ logic

ƒ main():
    logic_obj = logic.CalculatorLogic()
    gui.CalculatorGUI(logic_obj)

main()
